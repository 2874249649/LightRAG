# 当前问题概述

现有部署中每个知识库 (Workspace) 需通过独立端口访问，带来以下困扰：

- 同一主机需要拉起多套服务实例并管理多个端口；
- WebUI 无法在一个界面内切换不同 Workspace，用户操作体验差。

目标：所有 Workspace 共用单一 9621 端口；后端将 API 调整为 `http://host:9621/api/workspaces/{workspace_id}/...`，前端实现 Workspace 列表与切换能力，并妥善处理“无工作区”或“切换中”状态。

---

# 后端改动计划（FastAPI）

## 1. Workspace 启动配置与注册表

- 新增配置入口：优先读取 `WORKSPACES` 环境变量（逗号分隔），或在 `rag_storage/workspaces.yaml` 中维护工作区清单及元信息（显示名称、描述、可用状态）；若均未配置，则回落到单一 `args.workspace`。  
- 启动时根据清单逐个构造 `LightRAG` 与 `DocumentManager`，串行执行 `initialize_storages()` 与 `initialize_pipeline_status(workspace_id)`；失败的工作区标记为 `enabled=false` 并记录原因。  
- 引入 `WorkspaceRegistry` 单例，缓存 `{workspace_id: WorkspaceContext}`（含实例、文案、状态）；在 `lifespan` 启动与结束阶段负责逐个初始化/回收，并暴露 `list_workspaces()`、`get()`、`shutdown_all()` 等接口。

## 2. 路由与依赖调整

- 使用 `/api/workspaces/{workspace_id}` 作为所有业务 API 的统一前缀：  
  - 在 `app.include_router` 时附加 `Depends(apply_workspace_context)` 依赖，校验工作区并写入 `contextvars`；  
  - 文档、查询、图谱、流式接口等都通过 `get_current_workspace()` 获取实际实例，避免在路由函数签名中显式传参。  
- 现有 `/api/health` 继续返回全局信息，并附上工作区摘要；新增 `GET /api/workspaces/{workspace_id}/health` 透出单个工作区的配置、Pipeline 状态等细节。  
- 为文档上传、后台任务、清理等异步流程，统一在任务提交前注入当前工作区的真实实例，避免执行期丢失上下文。

## 3. 共享状态与日志

- 将 Pipeline 状态等共享命名空间改造为按工作区分区（例如 `pipeline_status:{workspace_id}`），`LightRAG` 内获取共享数据时统一使用带 Workspace 的命名。  
- 更新日志输出与 API 响应：所有关键日志、错误信息附带 `workspace_id`，便于资产隔离后的排查。

## 4. 文档与收尾

- 在 `AGENTS.md`、`docs` 中补充 Workspace 配置方式、默认输入目录隔离、以及新的 API 前缀示例。  
- `lifespan` 结束阶段调用 `registry.shutdown_all()`，逐个 `finalize_storages()` 并释放共享资源，确保多实例共存时退出行为一致。

---

# 前端改动计划（WebUI）

## 1. 状态管理

- 新建 `useWorkspaceStore` (Zustand)：  
  - 状态：`workspaces`、`currentWorkspace`、`loading`、`error`；  
  - 方法：`fetchWorkspaces(force?: boolean)`、`setWorkspace(id)`、`resetCurrentWorkspace()`；  
  - 将最近一次选择持久化到 `localStorage`，以便刷新后恢复。

## 2. API 调整

- 保留全局 `axiosInstance`，新增 `buildWorkspaceUrl(path: string)` 助手函数，根据 `currentWorkspace` 拼接 `/api/workspaces/${workspaceId}${path}`；未选择 workspace 时抛出可识别错误。  
- 对现有 API（文档、图谱、查询、健康检查等）统一改用 `buildWorkspaceUrl`；新增 `getWorkspaces()` 调用 `/api/workspaces`，返回工作区清单与元信息。  
- 处理无工作区/禁用工作区场景：`fetchWorkspaces` 将 `currentWorkspace` 置空，并通过 store 暴露错误信息。

## 3. UI 与交互

- 在 `SiteHeader` 添加 Workspace 下拉选择：  
  - 初始化时显示 Skeleton，加载失败给予错误提示和刷新按钮；  
  - 展示工作区名称与描述，禁用状态置灰；  
  - 选择后调用 `setWorkspace` 并触发相关 store (`useBackendState`, `useGraphStore`, 等) 的 `reset()` 方法。  
- App 启动流程：  
  - `App.tsx` 首次渲染调用 `fetchWorkspaces()`；  
  - 若存在 `currentWorkspace`，等待其加载完成后再触发健康检查与数据轮询；  
  - 若列表为空或全部禁用，展示专门的“无可用知识库”页，引导管理员配置。  
- Uploaded Documents 容器：  
  - 依赖 `currentWorkspace`，为空时展示空态卡片（沿用现有 `EmptyCard`）；  
  - 切换工作区时重置分页、筛选、排序并立即执行一次 `fetchPaginatedDocuments()`，确保列表刷新；  
  - 手动刷新按钮与轮询逻辑在 workspace 变化后重新启动。  
- 其他模块（图谱、检索等）在 `currentWorkspace` 缺失时禁用操作并显示提示。

## 4. 文案与说明

- 更新多语言文案，新增“请选择工作区”“当前没有可用知识库”等字符串，SiteHeader、空态页与提示框保持一致语义。  
- 在开发文档与部署说明中加入请求示例（`GET /api/workspaces/{id}/documents` 等），帮助前后端快速定位新的路径规则。

---

# 运维建议

- 在 `.env`（或独立配置文件）中维护 `WORKSPACES` 与对应描述，确保启动时即可创建所有工作区；  
- 确保 `inputs/{workspace_id}`、`rag_storage/{workspace_id}` 目录存在且具备读写权限；  
- 记录每次工作区启停与异常到日志中，便于后续排查。

---

# 时间评估（粗略）

- 后端路由与注册表改造：约 2.5 天（含测试与文档）；  
- 前端状态管理、API 改造与 UI 调整：约 2 天；  
- 联调与回归测试：约 0.5 天；  
- 总计：≈ 5 人日（视代码评审与内测反馈而定）。

---

# 实施记录（2025-02-14）

- 已实现 `WorkspaceRegistry` 及 `workspaces.yaml` 配置解析，服务启动时自动加载全部 Workspace 并通过 `/api/workspaces/{workspace_id}` 路由对外提供文档、查询、图谱与 Ollama 接口。  
- `pipeline_status` 等共享数据结构按 Workspace 分区，后台任务与流式接口在执行前读取当前请求上下文，确保隔离。  
- WebUI 新增 Workspace Store、下拉选择组件与 API 构建助手，未选择 Workspace 时阻断主要功能并提示管理员配置；切换工作区会重新挂载各功能面板并触发数据刷新。  
- README 增加多 Workspace 配置说明，同时补充 `workspaces.yaml.example` 模板，便于部署时快速复制使用。
